<html>
  <head>
    <style>
html, body {
  background: #222;
  color: #eee;
  font-size: 18px;
  font-family: Helvetica, Roboto;
}
form {
  display: flex;
  flex-direction: column;
  gap: 5px;
}
input[type=number] {
  text-align: right
}
    </style>
  </head>
  <body>
    <main id="app"></main>
    <script type="module">
import { app } from "https://unpkg.com/hyperapp"
import {
  main,
  h1, h2, h3,
  button,
  text,
  section,
  label,
  form,
  input,
  ul, li,
} from "https://unpkg.com/@hyperapp/html?module"

const inrange = (a, x, b) => (a <= x) && (x <= b)
const log10 = (x) => Math.log(x) / Math.log(10)

const PI = Math.PI
const STEFAN = 5.670374419E-8
const WIEN = 2.897771955E-3
const EDDINGTON = 3.2E4

const formulae = {
  "distance-modulus": {
    name: "distance modulus",
    order: [ "d" , "M", "m", "µ" ],
    variables: {
      µ: {
        name: "distance modulus",
        symbol: "µ",
        value: 10,
        formula: ({ m, M }) => ( m - M ),
      },
      m: {
        name: "apparent magnitude",
        symbol: "m",
        value: 5,
        formula: ({ µ, M }) => ( µ + M ),
      },
      M: {
        name: "absolute magnitude",
        symbol: "M",
        value: -5,
        formula: ({ µ, m }) => ( m - µ ),
      },
      d: {
        name: "distance",
        symbol: "d",
        value: 1000,
        unit: "parsecs",
        formula: ({ µ }) => ( Math.pow(10, (µ + 5) / 5) ),
      },
    },
  },
  "small-angle": {
    name: "small angle formula",
    order: [ "D", "d", "θ" ],
    variables: {
      θ: {
        name: "angular diameter ",
        symbol: "θ",
        value: 10,
        unit: "arcseconds",
        formula: ({ d, D }) => ( 206265*d/D ),
      },
      d: {
        name: "linear diameter",
        symbol: "d",
        value: 5,
        unit: "$Length",
        formula: ({ θ, D }) => ( θ*D/206265 ),
      },
      D: {
        name: "distance",
        symbol: "D",
        value: -5,
        unit: "$Length",
        formula: ({ θ, d }) => ( d*206265/θ )
      },
    },
  },
  "parallax": {
    name: "parallax distance",
    order: [ "p", "d" ],
    variables: {
      d: {
        name: "distance",
        symbol: "d",
        value: 10,
        unit: "parsecs",
        formula: ({ p }) => ( 1/p ),
      },
      p: {
        name: "parallax",
        symbol: "p",
        value: 0.1,
        unit: "arcseconds",
        formula: ({ d }) => ( 1/d ),
      },
    },
  },
  "magnitude-luminosity": {
    name: "magnitude-luminosity relation",
    order: [ "M_B", "M_A", "L_B", "L_A" ],
    variables: {
      L_A: {
        name: "luminosity A",
        symbol: "L_A",
        value: 10,
        unit: "Watts",
        formula: ({ L_B, M_B, M_A }) => ( L_B * Math.pow(100, (M_B - M_A) / 5) ),
      },
      L_B: {
        name: "luminosity B",
        symbol: "L_B",
        value: 10,
        unit: "Watts",
        formula: ({ L_A, M_B, M_A }) => ( L_A / Math.pow(100, (M_B - M_A) / 5) ),
      },
      M_A: {
        name: "magnitude A",
        symbol: "M_A",
        value: 10,
        unit: "",
        formula: ({ L_A, L_B, M_B }) => ( M_B - 2.5 * log10(L_A / L_B) ),
      },
      M_B: {
        name: "magnitude B",
        symbol: "M_B",
        value: 10,
        unit: "",
        formula: ({ L_A, L_B, M_A }) => ( M_A + 2.5 * log10(L_A / L_B) ),
      },
    },
  },
  "mass-luminosity": {
    name: "mass-luminosity relation",
    order: [ "M", "L" ],
    variables: {
      L: {
        name: "luminosity",
        symbol: "L",
        value: 10,
        unit: "L⊙",
        formula: ({ M }) => ( 
            inrange(0.00, M, 0.43) ? 0.23 * Math.pow(M, 2.3)
          : inrange(0.43, M, 2.00) ? 1.00 * Math.pow(M, 4.0)
          : inrange(2.00, M, 55.0) ? 1.40 * Math.pow(M, 3.5)
          : inrange(55.0, M, 1000) ? 32000 * Math.pow(M, 1.0)
          : NaN
        ),
      },
      M: {
        name: "mass",
        symbol: "M",
        value: 10,
        unit: "M⊙",
        formula: ({ L }) => ( Math.pow(L/1.40, 1/3.5) ),
      },
    },
  },
  "stefan-boltzmann": {
    name: "Stefan-Boltzmann Law",
    order: [ "T", "R", "L" ],
    variables: {
      L: {
        name: "luminosity",
        symbol: "L",
        value: 10,
        unit: "Watts",
        formula: ({ R, T }) => ( 4 * PI * STEFAN * (R*R) * (T*T*T*T) ),
      },
      R: {
        name: "radius",
        symbol: "R",
        value: 10,
        unit: "meters",
        formula: ({ L, T }) => ( Math.sqrt(L / (4 * PI * STEFAN * (T*T*T*T))) ),
      },
      T: {
        name: "radius",
        symbol: "R",
        value: 10,
        unit: "meters",
        formula: ({ L, R }) => ( Math.pow(L / (4 * PI * STEFAN * (R*R)), 0.25) ),
      },
    },
  },
  "stefan-boltzmann": {
    name: "Stefan-Boltzmann Law",
    order: [ "T", "R", "F", "L" ],
    variables: {
      L: {
        name: "luminosity",
        symbol: "L",
        value: 10,
        unit: "Watts",
        formula: ({ R, F }) => ( 4 * PI * (R*R) * F),
      },
      R: {
        name: "radius",
        symbol: "R",
        value: 10,
        unit: "meters",
        formula: ({ L, F }) => ( Math.sqrt(L / (4 * PI * F)) ),
      },
      F: {
        name: "flux",
        symbol: "F",
        value: 10,
        unit: "Watts / meters²",
        formula: ({ T }) => ( STEFAN * T*T*T*T )
      },
      T: {
        name: "temperature",
        symbol: "T",
        value: 10,
        unit: "meters",
        formula: ({ F }) => ( Math.pow(F/STEFAN, 0.25) ),
      },
    },
  },
  "wien": {
    name: "Wien's Displacement Law",
    order: [ "T", "λ" ],
    variables: {
      λ: {
        name: "wavelength",
        symbol: "λ",
        value: 0.05,
        unit: "meters",
        formula: ({ T }) => ( WIEN / T ),
      },
      T: {
        name: "temperature",
        symbol: "T",
        value: 0.06,
        unit: "Kelvin",
        formula: ({ λ }) => ( WIEN / λ ),
      },
    },
  },
  "eddington": {
    name: "Eddington Luminosity",
    order: [ "M", "L" ],
    variables: {
      L: {
        name: "luminosity",
        symbol: "L",
        value: 32000,
        unit: "L⊙",
        formula: ({ M }) => ( EDDINGTON * M ),
      },
      M: {
        name: "mass",
        symbol: "M",
        value: 1,
        unit: "M⊙",
        formula: ({ L }) => ( L / EDDINGTON ),
      },
    },
  },
  "leavitt-classical": {
    name: "period-luminosity relation (Leavitt Law), Classical Cepheids",
    order: [ "P", "M_V" ],
    variables: {
      M_V: {
        name: "visual absolute magnitude",
        symbol: "M_V",
        value: -4.05,
        unit: "",
        formula: ({ P }) => ( -2.43 * (log10(P) - 1) - 4.05 ),
      },
      P: {
        name: "period",
        symbol: "P",
        value: 10,
        unit: "days",
        formula: ({ M_V }) => ( Math.pow(10, (M_V + 4.05)/(-2.43) + 1) ),
      },
    },
  },
  "leavitt-ii": {
    name: "period-luminosity relation (Leavitt Law), Type II Cepheids",
    order: [ "P", "M_V" ],
    variables: {
      M_V: {
        name: "visual absolute magnitude",
        symbol: "M_V",
        value: -2.66,
        unit: "",
        formula: ({ P }) => ( -2.81 * log10(P) + 0.15 ),
      },
      P: {
        name: "period",
        symbol: "P",
        value: 10,
        unit: "days",
        formula: ({ M_V }) => ( Math.pow(10, (M_V + 0.15)/(-2.81)) ),
      },
    },
  },
  "lifespan": {
    name: "lifespan",
    order: [ "M", "t" ],
    variables: {
      t: {
        name: "lifespan",
        symbol: "t",
        value: 10000000000,
        unit: "years",
        formula: ({ M }) => ( Math.pow(M, 2.5) * 1E10 ),
      },
      M: {
        name: "mass",
        symbol: "M",
        value: 10,
        unit: "M⊙",
        formula: ({ t }) => ( Math.pow(t*1E-10, 1/2.5) ),
      },
    },
  },
}

const Calculate = (form_id, variable_id) => ( state, event ) => {
  const form = state.formulae[form_id]
  const variables = form.variables
  
  // Update inputted variable
  variables[variable_id].value = event.target.value
  
  // Flatten values of variables
  const values = Object.fromEntries(Object.entries(variables).map(
    ([v_id, v]) => ([v_id, Number(v.value)])
  ))
    
  // Calculate other variables in order
  for(const v_id of form.order) {
    if(v_id == variable_id) continue
    console.log(v_id)
    const v = variables[v_id]
    values[v_id] = Number(v.formula(values))
    v.value = values[v_id]
  }
  return { ...state }
}

const Reorder = (form_id, variable_id) => ( state, event ) => {
  const form = state.formulae[form_id]
  const variables = form.variables

  // Move current variable to last in calculation order
  form.order.push(form.order.splice(form.order.indexOf(variable_id), 1)[0])
  
  for(const v_id of form.order) {
    const i = form.order.indexOf(v_id) / (form.order.length - 1)
    variables[v_id].prefix = (
        i == 1 ? '➡️ '
      : i == 0 ? '⭐ '
      : ''
    )
  }
  
  return { ...state }
}

app({
  init: { formulae },
  view: ({ formulae }) =>
    main([
      h1(text('ASTROFORMULATRON')),
      h3(text('An astronomy calculator by Xing')),
      ul(Object.entries(formulae).map(([f_id, f]) => 
        li({id: f_id}, form([
          text(f.name),
          ul(Object.entries(f.variables).map(([v_id, v]) => 
            li({id: f_id}, label([
              text(v.prefix || '🌃 '),
              text(v.name + " " + v.symbol + " = "),
              input({
                type: "number", 
                value: v.value,
                oninput: Calculate(f_id, v_id),
                onfocus: Reorder(f_id, v_id),
              }),
              v.unit && text(v.unit)
            ]))
          ))
        ]))
      )),
      text("Made with hyperapp.js")
    ])
  ,
  node: document.getElementById("app"),
})


    </script>
  </body>
</html>
